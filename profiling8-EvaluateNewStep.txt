So far it seems like it works as expected. I would keep this separate branch for a while though.
I will try to implement the changes into the Numerical Inverse as well first to see
if something kicks back or not.


Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    88                                               @profile
    89                                               def EvaluateNewStep(self):
    90                                                   # evaluate new boundary vector (BC means boundary condition)
    91     14502     125137.0      8.6     10.3          self.b = self.b_base.dot(self.T)  # Assemble vector b (dot() is matrix multiplication)
    92     14502      19541.0      1.3      1.6          self.b[0] += self.dt*(1-self.theta)*self.HeatFlux[self.current_step_idx]  # apply explicit portion of HeatFlux (Neumann BC 1st node)
    93     14502      14251.0      1.0      1.2          self.b[0] += self.dt*self.theta*self.HeatFlux[self.current_step_idx+1]  # apply implicit portion of HeatFlux (Neumann BC 1st node)
    94     14502      16441.0      1.1      1.4          self.b[-1] -= self.dt*(1-self.theta)*self.Exp_data.RobinAlpha*self.T[-1]  # apply explicit contribution of the body temperature (Robin BC Nth node)
    95     14502      14060.0      1.0      1.2          self.b[-1] += self.dt*(1-self.theta)*self.Exp_data.RobinAlpha*self.T_amb[self.current_step_idx]  # apply explicit contribution of the ambient temperature (Robin BC Nth node)
    96     14502      13616.0      0.9      1.1          self.b[-1] += self.dt*self.theta*self.Exp_data.RobinAlpha*self.T_amb[self.current_step_idx+1]  # apply implicit contribution of the ambient temperature (Robin BC Nth node)
    97
    98                                                   # solve the equation self.A*self.T=b
    99     14502     971012.0     67.0     80.1          self.T = spsolve(self.A, self.b)  # solve new self.T for the new step
   100                                                   #self.T_x0.append(np.interp(self.Exp_data.x0, self.x, self.T))  # save data from the temperature probes  # switching it off for now
   101     14502       8681.0      0.6      0.7          self.current_step_idx += 1  # move to new timestep
   102     14502      30232.0      2.1      2.5          self.T_x0[self.current_step_idx] = self.T_x0_interpolator(self.T)
